/*
 * Transactional API
 * # Introduction    This API is a service provided by [E-goi](www.e-goi.com) to send transactional messages.    Transactional Messaging is a 1-to-1 communication channel, usually from an organization directed to a specific consumer.   They can be triggered by:    * __Actions__ - The consumer interacts with the organization (ie.: online shopping);  * __Time__ - The consumer's actions are time-bounded by the organization (ie.: period of inactivity).    Because of the nature of these messages,   it is expected that the consumer is interested in the content of these messages.   Therefore, they have a different treatment from marketing messages, and have a higher acceptance and opening rate.    >DISCLAIMER  >  >Please notice that this platform is more delicate in regards to the nature and processing of its messages.  >  >It should NOT be used as a mean of mass marketing, scams, phishing or overall unruly behaviour.   >  >Failure to comply may lead to limitation of use and even termination of account.    ***
 *
 * OpenAPI spec version: V2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * The message and its triggering condition
 */
@Schema(description = "The message and its triggering condition")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-09-25T18:24:45.836079+01:00[Europe/Lisbon]")
public class MultiChannelMessageObject {
  @SerializedName("channel")
  private String channel = null;

  @SerializedName("interval")
  private Integer interval = null;

  /**
   * The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel --- | --- | --- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email
   */
  @JsonAdapter(ConditionEnum.Adapter.class)
  public enum ConditionEnum {
    NONE("none"),
    NOT_OPEN("not_open"),
    OPEN("open"),
    CLICK("click"),
    NOT_CLICK("not_click");

    private String value;

    ConditionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ConditionEnum fromValue(String text) {
      for (ConditionEnum b : ConditionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ConditionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConditionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConditionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ConditionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("condition")
  private ConditionEnum condition = null;

  @SerializedName("templateId")
  private Integer templateId = null;

  @SerializedName("subject")
  private String subject = null;

  @SerializedName("textBody")
  private String textBody = null;

  @SerializedName("htmlBody")
  private String htmlBody = null;

  public MultiChannelMessageObject channel(String channel) {
    this.channel = channel;
    return this;
  }

   /**
   * Available communications channels in the API. Currently there are Emails and Sms.
   * @return channel
  **/
  @Schema(example = "email", required = true, description = "Available communications channels in the API. Currently there are Emails and Sms.")
  public String getChannel() {
    return channel;
  }

  public void setChannel(String channel) {
    this.channel = channel;
  }

  public MultiChannelMessageObject interval(Integer interval) {
    this.interval = interval;
    return this;
  }

   /**
   * the interval in seconds between the message and the previous. Defaults to 3600s (1h).
   * @return interval
  **/
  @Schema(example = "3600", description = "the interval in seconds between the message and the previous. Defaults to 3600s (1h).")
  public Integer getInterval() {
    return interval;
  }

  public void setInterval(Integer interval) {
    this.interval = interval;
  }

  public MultiChannelMessageObject condition(ConditionEnum condition) {
    this.condition = condition;
    return this;
  }

   /**
   * The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel --- | --- | --- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email
   * @return condition
  **/
  @Schema(example = "none", description = "The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel --- | --- | --- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email")
  public ConditionEnum getCondition() {
    return condition;
  }

  public void setCondition(ConditionEnum condition) {
    this.condition = condition;
  }

  public MultiChannelMessageObject templateId(Integer templateId) {
    this.templateId = templateId;
    return this;
  }

   /**
   * the template id already in the system. overrides subject, textBody and htmlBody.
   * @return templateId
  **/
  @Schema(example = "1234", description = "the template id already in the system. overrides subject, textBody and htmlBody.")
  public Integer getTemplateId() {
    return templateId;
  }

  public void setTemplateId(Integer templateId) {
    this.templateId = templateId;
  }

  public MultiChannelMessageObject subject(String subject) {
    this.subject = subject;
    return this;
  }

   /**
   * The subject of the message. Only applies to email messages.
   * @return subject
  **/
  @Schema(example = "Welcome", description = "The subject of the message. Only applies to email messages.")
  public String getSubject() {
    return subject;
  }

  public void setSubject(String subject) {
    this.subject = subject;
  }

  public MultiChannelMessageObject textBody(String textBody) {
    this.textBody = textBody;
    return this;
  }

   /**
   * The text body of the message.
   * @return textBody
  **/
  @Schema(example = "Welcome to the club, {{ name }}", description = "The text body of the message.")
  public String getTextBody() {
    return textBody;
  }

  public void setTextBody(String textBody) {
    this.textBody = textBody;
  }

  public MultiChannelMessageObject htmlBody(String htmlBody) {
    this.htmlBody = htmlBody;
    return this;
  }

   /**
   * The html body of the message. Only applies to email messages.
   * @return htmlBody
  **/
  @Schema(example = "<b>Welcome to the club, {{ name }}!</b>", description = "The html body of the message. Only applies to email messages.")
  public String getHtmlBody() {
    return htmlBody;
  }

  public void setHtmlBody(String htmlBody) {
    this.htmlBody = htmlBody;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MultiChannelMessageObject multiChannelMessageObject = (MultiChannelMessageObject) o;
    return Objects.equals(this.channel, multiChannelMessageObject.channel) &&
        Objects.equals(this.interval, multiChannelMessageObject.interval) &&
        Objects.equals(this.condition, multiChannelMessageObject.condition) &&
        Objects.equals(this.templateId, multiChannelMessageObject.templateId) &&
        Objects.equals(this.subject, multiChannelMessageObject.subject) &&
        Objects.equals(this.textBody, multiChannelMessageObject.textBody) &&
        Objects.equals(this.htmlBody, multiChannelMessageObject.htmlBody);
  }

  @Override
  public int hashCode() {
    return Objects.hash(channel, interval, condition, templateId, subject, textBody, htmlBody);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MultiChannelMessageObject {\n");
    
    sb.append("    channel: ").append(toIndentedString(channel)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    condition: ").append(toIndentedString(condition)).append("\n");
    sb.append("    templateId: ").append(toIndentedString(templateId)).append("\n");
    sb.append("    subject: ").append(toIndentedString(subject)).append("\n");
    sb.append("    textBody: ").append(toIndentedString(textBody)).append("\n");
    sb.append("    htmlBody: ").append(toIndentedString(htmlBody)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
